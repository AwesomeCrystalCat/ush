// t_len_name *mx_creat_len() {
//     t_len_name *len = malloc(t_len_name);
//     len->n_bute = 1;
//     len->n_len = 0;
//     len->n_cursor = 0;
//     len->cur_pos_x = 0;
//     len->n_cursor_b = 1;
//     len->col = 0;
//     len->cursor_delta_len = 1;
//     len->cursor_delta_b = 0;
//     len->first_line = true;
//     len->buf_first = NULL;
//     len->first_line_len = 0;
//     len->first_line_byte = 1;
//     len->mystr[0] = '\0';
//     return len;
// }

// unsigned char *mx_read_line(bool *trig, t_history_name **history) {
//     struct termios savetty;
//     struct termios tty;
//     t_len_name *len = mx_creat_len();

//     tcgetattr (0, &tty);
//     savetty = tty;
//     tty.c_lflag &= ~(ICANON | ECHO | ISIG);
//     tty.c_cc[VMIN] = 1;
//     tcsetattr (0, TCSAFLUSH, &tty);
//     mx_get_twidth(len->col);
//     mx_printstr("u$h> ");
    

//     while (1) {
//         read (0, len->ch, 4);
//         mx_get_twidth(len->col);
//         if (len->ch[0] != 27 && len->ch[0] != 9 ) {
//             if (len->n_cursor + 5  > len->col) {
//                 fprintf(stdout, "\033[%dF", (len->n_cursor + 4)/len->col);
//                 fflush(stdout);
//             }
//             else {
//                 mx_printstr("\033[1G");
//             }
//             mx_printstr("\033[0J");
//             mx_printstr("u$h> ");

//             if (len->ch[0] == 127 && len->ch[1] == 0 && len->ch[2] == 0 && len->ch[3] == 0) {
//                 back_to_str(len->mystr, &n_bute, &n_len, &n_cursor, &n_cursor_b);
//             }
//         else if (ch[0] == '\n' || ch[0] == '\0') {
//             if (ch[0] != '\n') 
//                     *trig = true;
//                 fprintf(stdout, "%s", mystr);
//                 fflush(stdout);
//                 write(1, "\n", 1);
//                 if (mx_strcmp("exit", mystr) == 0) {
//                     if (malloc_size(buf_first))
//                         free(buf_first);
//                     if (malloc_size(mystr))
//                         free(mystr);
//                     mx_delete_history(history);
//                     exit(0);
//                 }
                    
//                 break;
//             }
//             else if (ch[0] != 27) {
//                 add_to_str(&mystr, ch, &n_bute, &n_len, &n_cursor, &n_cursor_b);
//             }
//             fprintf(stdout, "%s", mystr);
//             fflush(stdout);
//             cur_pos_x = col - ((((n_cursor + 4)/col + 1) * col) - (n_cursor + 5)) + 1;
            

//             if ((((n_len + 4)/col - (n_cursor + 4)/col)) > 0) {
//                 fprintf(stdout, "\033[%dF", ((n_len + 4)/col - (n_cursor + 4)/col));
//                 fprintf(stdout, "\033[%dG", cur_pos_x);
//                 fflush(stdout);
//             }
//             else {
//                 fprintf(stdout, "\033[%dG", cur_pos_x);
//                 fflush(stdout);
//             }
//         }
//         cur_pos_x = col - ((((n_cursor + 5)/col + 1) * col) - (n_cursor + 5)) + 1;

        
//          if (ch[0] == 27 && ch[1] == 91 && ch[2] == 68) {// errow left
//             if (n_cursor > 0) {
//                 mx_byte_check_back(mystr, &cursor_delta_len, &cursor_delta_b, n_cursor_b);
//                 cur_pos_x = cur_pos_x - cursor_delta_len;
//                 n_cursor = n_cursor - cursor_delta_len;
//                 n_cursor_b = n_cursor_b - cursor_delta_b;
//                 cursor_delta_len = 1;
//                 if (cur_pos_x < 1) {
//                     fprintf(stdout, "\033[%dF",1);
//                     fprintf(stdout, "\033[%dG", col);
//                     fflush(stdout);
//                     cur_pos_x = col;
//                 }
//                 else { 
//                     fprintf(stdout, "\033[%dG", cur_pos_x);
//                     fflush(stdout);
//                 }
//             }
//          }
        
//         if (ch[0] == 27 && ch[1] == 91 && ch[2] == 67) {// errow right
//             if (n_cursor < n_len) {
//                 mx_byte_check_add(mystr, &cursor_delta_len, &cursor_delta_b, n_cursor_b);
//                 cur_pos_x = cur_pos_x + cursor_delta_len;
//                 n_cursor = n_cursor + cursor_delta_len;
//                 n_cursor_b = n_cursor_b + cursor_delta_b;
//                 cursor_delta_len = 1;
//                 if (cur_pos_x > col) {
//                     fprintf(stdout, "\033[%dE",1);
//                     fprintf(stdout, "\033[%dG", 1);
//                     fflush(stdout);
//                     cur_pos_x = 1;
//                 }
//                 else {
//                     fprintf(stdout, "\033[%dG", cur_pos_x);
//                     fflush(stdout);
//                 }
//             }
//          }
//          if (ch[0] == 27 && ch[1] == 91 && ch[2] == 65) {// errow up
//             if (*history != NULL) {
//                 if (first_line == true) {
//                     first_line_len = n_len;
//                     first_line_byte = n_bute;
//                     buf_first = strdup((char *) mystr);
//                     free(mystr);
//                     first_line = false;
//                 }
//                 if (n_cursor + 5 > col) {
//                     fprintf(stdout, "\033[%dF", (n_cursor + 4)/col);
//                     fflush(stdout);
//                 }
//                 else {
//                     mx_printstr("\033[1G");
//                     }
//                 mx_printstr("\033[0J");
//                 mx_printstr("u$h> ");
//                 n_cursor =(*history)->n_len;
//                 n_cursor_b = (*history)->n_byte;
//                 n_len = n_cursor;
//                 n_bute = n_cursor_b;
//                 mystr = (*history)->name;
//                 fprintf(stdout, "%s", (*history)->name);
//                 fflush(stdout);
//                 if ((*history)->next)
//                     (*history) = (*history)->next;
//            }
//          }
//         if (ch[0] == 27 && ch[1] == 91 && ch[2] == 66) { // errow down
//                 if ((*history)->previous != NULL || first_line == false) {
                    
//                 if (n_cursor + 5 > col) {
//                     fprintf(stdout, "\033[%dF", (n_cursor + 4)/col);
//                     fflush(stdout);
//                 }
//                 else {
//                     mx_printstr("\033[1G");
//                     }
//                 mx_printstr("\033[0J");
//                 mx_printstr("u$h> ");
//                 if ((*history)->previous != NULL) {
//                     (*history) = (*history)->previous;
//                     n_cursor =(*history)->n_len;
//                     n_cursor_b = (*history)->n_byte;
//                     n_len = n_cursor;
//                     n_bute = n_cursor_b;
//                     mystr = (*history)->name;
//                     fprintf(stdout, "%s", (*history)->name);
//                     fflush(stdout);
//                 }
//                 else {
//                     if (first_line == false) {
//                         n_cursor = first_line_len;
//                         n_cursor_b = first_line_byte;
//                         n_len = first_line_len;
//                         n_bute = n_cursor_b;
//                         mystr = (unsigned char *) buf_first;
//                         fprintf(stdout, "%s", mystr);
//                         fflush(stdout);
//                         first_line = true;
//                         first_line_len = 0;
//                         first_line_byte = 1;
//                     }
//                 }
//             }
//         }
//         ch[0] = 0;
//         ch[1] = 0;
//         ch[2] = 0;
//         ch[3] = 0;
//     }

//     if (first_line != true)
//         free(buf_first);
//     if (mystr[0] == '\n')
//         free(mystr);
//     else 
//         mx_push_back_history(history, mystr, n_bute, n_len);
//     tcsetattr (0, TCSAFLUSH, &savetty);
//     return mystr;
// }

// void hdl(int sig)
// {
//     sig = sig +1 - 1;
//     printf("%d - pid\n", getpid());
//     printf("\n");
// }

// void ush_loop(void) {
//     unsigned char *line;
//     int status = 2;
//     // t_queue **work = NULL;
//     // t_queue *p = NULL;
//     bool trig = false;
//     t_history_name *history = NULL;

//     while (trig == false) {
//         printf("u$h> ");
//         line = mx_read_line(&trig, &history);
//         // if (line[0] != '\0') {
//         //     work = mx_works_queue((char *)line);
//         //     for (int i = 0; work[i]; i++) {
//         //         p = work[i];
//         //         for (; p; p = (*p).next) {
//         //             (*p).command = mx_substitute((*p).command);
//         //             status = mx_redirection((*p).command);
//         //             if (((*p).op == '&' && status == 1)
//         //                 || ((*p).op == '|' && status == 0))
//         //                 {
//         //                     p = (*p).next;
//         //                 }
//         //         }
//         //     }
//         // }
//     }
// }

// int main(int argc, char **argv, char **envp) 
// {
//     struct sigaction act;
//     memset(&act, 0, sizeof(act));
//     act.sa_handler = hdl;
//     sigset_t set;
//     sigemptyset(&set);
//     act.sa_mask = set;
//     sigaddset(&set, SIGINT);
//     sigaddset(&set, SIGTSTP);
//     signal(SIGINT, hdl);
//     signal(SIGTSTP, hdl);
//     signal(SIGTTIN, hdl);
//     signal(SIGTTOU, hdl);
//     signal(SIGQUIT, hdl);
//     ush_loop();
//     // lsh_loop();
//     return 0;
// }

// // void mx_byte_check_add(unsigned char *ch, int *delte_len, int *delta_byte,
// //                        int start) {
// //     if (ch[start] >> 7 == 0)
// //         *delta_byte = 1;
// //     if (ch[start] >> 5 == 6 && ch[start + 1] >> 6 == 2 )
// //         *delta_byte = 2;
// //     if (ch[start] >> 4 == 14 && ch[start + 1] >> 6 == 2
// //         && ch[start + 2] >> 6 == 2 )
// //         *delta_byte = 3;
// //     if (ch[start] >> 3 == 30 && ch[start + 1] >> 6 == 2 
// //         && ch[start + 2] >> 6 == 2 && ch[start + 3] >> 6 == 2) {
// //         *delta_byte = 4;
// //         *delte_len = 2;
// //     }
// // }

// // void mx_byte_check_back(unsigned char *str, int *len, int *minus, int n) {
// //     if ( str[n-2] >> 7 == 0)
// //         *minus = 1;
// //     if (str[n-3] >> 5 == 6 && str[n-2] >> 6 == 2 )
// //         *minus = 2;
// //     if (str[n-4] >> 4 == 14 && str[n-3] >> 6 == 2 && str[n-2] >> 6 == 2 )
// //         *minus = 3;
// //     if (str[n-5] >> 3 == 30 && str[n-4] >> 6 == 2 && str[n-3] >> 6 == 2
// //         && str[n-2] >> 6 == 2) {
// //         *minus = 4;
// //         *len = 2;
// //     }
// // }



// // void add_to_str(unsigned char **str, unsigned char *ch, int *n, int *n_len, int *n_cursor, int *n_cursor_b) {
// //     int plus = 0;
// //     int len = 1;
// //     int buf_plus = 0;
// //     unsigned char *buf_str = NULL;

// //     mx_byte_check_add(ch, &len, &plus, 0);
// //     if (ch[0] >> 7 == 0 && ch[1] >> 7 == 0 && ch[2] >> 7 == 0 && ch[3] >> 7 == 0 && ch[1] != 0 && ch[2] != 0 && ch[3] != 0) {
// //         plus = 4;
// //         len = 4;
// // }

// //     if ((*n_cursor_b) == (*n)) {
// //         (*n) = (*n) + plus;
// //         (*n_cursor_b) = (*n_cursor_b) + plus;
// //         (*n_len) = (*n_len) + len;
// //         (*n_cursor) = (*n_cursor) + len;
// //         (*str) = (unsigned char *)realloc(*str, (*n));
// //         (*str)[(*n)-1] = '\0';
// //         buf_plus = plus;
// //         for (int i = 0; i < plus; i++) {
// //             (*str)[(*n)-1-buf_plus] = ch[i];
// //             buf_plus--;
// //         }
// //     }
// //     else {
// //         buf_str = (unsigned char *)malloc(sizeof(char) * ((*n) + plus));
// //         for (int i = 0; i < (*n_cursor_b) - 1; i++)
// //             buf_str[i] = (*str)[i];
// //         for (int i = 0; i < plus; i++)
// //             buf_str[(*n_cursor_b) + i - 1] = ch[i];
// //         for (int i = (*n_cursor_b) + plus - 1; i <= (*n); i++)
// //             buf_str[i] = (*str)[i - plus];
// //         free(*str);
// //         *str = buf_str;
// //          (*n) = (*n) + plus;
// //          (*n_cursor_b) = (*n_cursor_b) + plus;
// //          (*n_cursor) = (*n_cursor) + len;
// //          (*n_len) = (*n_len) + len;
// //     }

// // }

// // void back_to_str(unsigned char **str, int *n, int *n_len, int *n_cursor, int *n_cursor_b) {
// //     int minus = 0;
// //     int len = 1;
// //     unsigned char *buf_str = NULL;
// //     int q = 0;

// //     mx_byte_check_back(*str, &len, &minus, *n);
// //     if ((*n_cursor_b) == (*n)) {
// //         if ((*n) > 1) {
// //             for (int i = 0; i < minus; i++) {
// //             (*str)[(*n) - 2 - i] = '\0';
// //         }
// //         (*n) = (*n) - minus;
// //         (*str) = (unsigned char *)realloc(*str, (*n));
// //         (*n_len) = (*n_len) - len;
// //         (*n_cursor) = (*n_cursor) - len;
// //         (*n_cursor_b) = (*n_cursor_b) - minus;
// //         }
// //     }
// //     else {
// //         if ((*n_cursor_b) > 1) {
// //             buf_str = (unsigned char *)malloc(sizeof(char) * ((*n) - minus));
// //             for (int i = 0; i < (*n_cursor_b) - minus - 1; i++)
// //                 buf_str[i] = (*str)[i];
// //             q = (*n_cursor_b) - minus - 1;
// //             for (int i = (*n_cursor_b) - 1; i < (*n); i++) {
// //                 buf_str[q] = (*str)[i];
// //                 q++;
// //             }
// //             free(*str);
// //             *str = buf_str;
// //             (*n_len) = (*n_len) - len;
// //             (*n_cursor) = (*n_cursor) - len;
// //             (*n_cursor_b) = (*n_cursor_b) - minus;
// //             (*n) = (*n) - minus;
// //         }
        
// //     }
// // }





// // #include <unistd.h>
// // #include <stdio.h>
// // #include <stdlib.h>
// // #include <termios.h>
// // #include <signal.h>
// // /* переменная для сохранения исходных атрибутов терминала */
// // struct termios saved_attributes;
// // void reset_input_mode(void)
// // {
// // tcsetattr(0, TCSANOW, &saved_attributes);
// // }
// // void sighnd(int signo)
// // {
// // exit(0);
// // }
// // void set_input_mode(void)
// // {
// // struct termios tattr;
// // /* проверяем, что вводим с терминала */
// // if (!isatty(0)) {
// // fprintf(stderr, "Not a terminal.\n");
// // exit(1);
// // }
// // /* считываем текущий режим работы терминала */
// // tcgetattr(0, &saved_attributes);
// // memcpy(&tattr, &saved_attributes, sizeof(tattr));
// // /* включаем неканонический режим без эха */
// // tattr.c_lflag &= ~(ICANON|ECHO);
// // /* считываем минимум по одному символу */
// // tattr.c_cc[VMIN] = 1;
// // /* без ограничения времени ожидания */
// // tattr.c_cc[VTIME] = 129;
// // /* устанавливаем новый режим работы терминала */
// // tcsetattr(0, TCSAFLUSH, &tattr);
// // }
// // int main(void)
// // {
// // char c;
// // set_input_mode();
// // atexit(reset_input_mode);
// // /* устанавливаем обработку сигналов завершения */
// // signal(SIGINT, sighnd);
// // signal(SIGTERM, sighnd);
// // while (1) {
// //     write(1, ">", 1);
// // while (read(0, &c, 1) != '\0') {
// //     if (c == '\004') break;
// //         write(1, &c, 1);
// //     }
// //     fflush(stdout);
// // }
// // return 0;
// // }

// // #include <unistd.h>
// // #include <stdio.h>
// // #include <stdlib.h>
// // #include <termios.h>

// // /* Use this variable to remember original terminal attributes. */

// // struct termios saved_attributes;

// // void
// // reset_input_mode (void)
// // {
// //   tcsetattr (STDIN_FILENO, TCSANOW, &saved_attributes);
// // }

// // void
// // set_input_mode (void)
// // {
// //   struct termios tattr;
// //   char *name;

// //   /* Make sure stdin is a terminal. */
// //   if (!isatty (STDIN_FILENO))
// //     {
// //       fprintf (stderr, "Not a terminal.\n");
// //       exit (EXIT_FAILURE);
// //     }

// //   /* Save the terminal attributes so we can restore them later. */
// //   tcgetattr (STDIN_FILENO, &saved_attributes);
// //   atexit (reset_input_mode);

// //   /* Set the funny terminal modes. */
// //   tcgetattr (STDIN_FILENO, &tattr);
// //   tattr.c_lflag &= ~(ICANON | ECHO); /* Clear ICANON and ECHO. */
// //   tattr.c_cc[VMIN] = 1;
// //   tattr.c_cc[VTIME] = 0;
// //   tcsetattr (STDIN_FILENO, TCSAFLUSH, &tattr);
// // }

// // int
// // main (void)
// // {
// //   char c;

// //   set_input_mode ();

// //   while (1)
// //     {
// //       read (STDIN_FILENO, &c, 1);
// //       if (c == '\004')          /* C-d */
// //         break;
// //       else
// //         putchar (c);
// //     }

// //   return EXIT_SUCCESS;
// // }

// // #include <unistd.h>
// // #include <stdio.h>
// // #include <termios.h>
// // #include <string.h>
// // #include <stdlib.h>

// // #define MAXBUFSIZE (10000U)
// // #define DEL (127)

// // int main(void) {
// //     char buf[MAXBUFSIZE]; //set buffer
// //     char c; //reading by chars
// //     size_t top; //top???
// //     struct termios curterm; //termios struct

// //     while (1) {
// //         write(1, "u$h>", 4);
// //     tcgetattr(STDIN_FILENO, &curterm);
// //     curterm.c_lflag &= ~(ICANON | ECHO);
// //     curterm.c_cc[VTIME] = 1;
// //     curterm.c_cc[VMIN] = 1;
// //     tcsetattr(STDIN_FILENO, TCSANOW, &curterm);

// //     top = 0;
// //     while (read(STDIN_FILENO, &c, sizeof c) == 1) {
// //         switch (c) {
// //             case DEL:
// //                 if (top) {
// //                     --top;
// //                     const char delbuf[] = "\b \b";
// //                     write(STDOUT_FILENO, delbuf, strlen(delbuf));
// //                 }
// //                 break;
// //             case '\n':
// //                 write(STDOUT_FILENO, &c, sizeof c);
// //                 write(STDOUT_FILENO, buf, top);
// //                 write(STDOUT_FILENO, "\n", 1);
// //                 top = 0;
// //                 break;
// //             default:
// //                 buf[top++] = c;
// //                 write(STDOUT_FILENO, &c, sizeof c);
// //                 break;
// //          }
// //     }
// //     }
// //     return 0;
// // }
